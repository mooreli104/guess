Day 1

Goal: 
Create a playable multiplayer web game with pure java in the backend. 
Learn what problems a framework like Spring solves.

The Java API for WebSocket consists of the following packages.

The javax.websocket.server package contains annotations, classes, and interfaces to create and configure server endpoints.

The javax.websocket package contains annotations, classes, interfaces, and exceptions that are common to client and server endpoints.

The process for creating and deploying a WebSocket endpoint follows.

1. Create an endpoint class.

2. Implement the lifecycle methods of the endpoint.

3. Add your business logic to the endpoint.

4. Deploy the endpoint inside a web application.

Java API for Websockets has 2 ways to create an endpoint.

1. Programmatic endpoint (extend Endpoint class and override lifecycle methods)
2. Annotated endpoint (Add annotations to a current class and its methods)

Annotated endpoints are easier to use 

Blocking methods pause the program until execution (sync) and non-blocking
methods allow the program to continue with other tasks (async).

Asynchronous programming is basically executing something without having to wait for it to complete. 

Map<String, Integer> hashMap = new HashMap<>();        // Hash table
Map<String, Integer> treeMap = new TreeMap<>();        // Red-black tree  
Map<String, Integer> concurrentMap = new ConcurrentHashMap<>(); // Thread-safe hash table
The interface on the left just says "I can do Map operations." 
The concrete class on the right says "Here's HOW I actually do those operations."

Unrelated but AWS stuff

EC2 instances are virtual machines that you can provision on AWS
    - unmanaged service; client manages the instances; aws manages the underlying infrastructure


Serverless - cannot access or see underlying infrastructure

AWS Lambda - function as a service; serverless computing

A Lambda is called when a Trigger occurs which could be anything

Lambda instance lasts ~15 minutes

Lambda is good for quick event driven processes

In cloud computing, the term “compute” describes concepts and objects related to software computation. It is a generic term used to reference processing power, memory, networking, storage, and other resources required for the computational success of any program. 

How Lambda works

1. Upload code to Lambda - Lambda Function
2. Configure your code to be triggered by events, like AWS services, mobile apps, or HTTP requests.
3. The Lambda runtime executes your function code using the event data passed to it. 
4. You are charged only for the compute time consumed, down to the millisecond. The price depends on the amount of memory that you allocate to your function.

Containers package code, dependencies, runtime, etc. Everything a program needs to run in a single, portable unit.
    - This creates an isolated and consistent environment.
    - Convenient to scale and deploy anywhere


Day 2

Maven is a build tool that helps with dependency management and build automation.

Maven works by using a pom.xml (Project Object MOdel) as a blueprint for a project. It specifies metdata 
like project name, version, and dependencies, and instructions for building, testing, and packaging.

Maven automatically downloads dependencies that are declared in pom.xml by first checking the
local Maven repository, then remote repositories and stores them in the local repository. 

An anynomous function is an inner class with no name. So it is a class that isnt defined with an (new) class name.
Useful for when you only need an implementation of a function for one thing. 

Each instance of the Endpoint class is associated with one connection.

An embedded server is a server that runs inside a Java application rather than a standalone process.


Day 3 (2 hours):

When you write a WebSocket application using the Jakarta EE jakarta.websocket APIs, your code typically need to depend on just the Jakarta EE WebSocket APIs to compile your application. However, at runtime you need to have an implementation of the Jakarta EE WebSocket APIs in your class-path/module-path.

When writing a WebSocket application with Jakarta EE APIS, your code usually only needs to depend on the 
Jarkarta EE WebSocket APIs. However at runtime, there must be an implementation of 
1. Jarkata EE Websocket APIs 
2. standard Jakarta EE 11 WebSocket APIS

Avaialble w/ Maven artifacts

To correctly configure a WebSocket app based on the standard Jakarta EE 11 Websocket APIs there are 2 steps:
1.  Make sure Jetty sets up an instance of jakarta.websocket.server.ServerContainer
2.  Configure the WebSocket endpoints that implement your application logic

2 ways to deploy web applications:
1. WebAppContext
2. ServletContextHandler

When using ServletContextHandle as in this project, JakartaWebSocketServletContainerInitializer must be initalized
to set up the ServerContainer. 

A servlet is a Java object that is managed by a Servlet container and handles HTTP requests.

A Servlet container is a type of web server that specifically runs Java servlets.

Lambas in Java are expressions that define a single instance of single method classes

The ServerContainer instance is stored as a ServletContext attribute

ServletContext - allows you to define and configure a web application's context, including adding servlets, filters, and listeners, and setting context attributes and init parameters.

Javax was renamed to Jakarta because Oracle gave stewardship of Java EE to the Eclipse foundation.

After a Server/ServerContainer is setup in Jetty, the endpoints must be configured which can be done a few ways.
1. standard jakarta.websocket annotations
2. extend the jakarta.websocket.Endpoint abstract class
3. or implement the jakarta.websocket.server.ServerApplicationConfig interface

Day summary 

Jetty is a Servlet container (a web server that runs Java servlets). A Servlet is a Java object managed
by a Servlet container and handles HTTP requests.

To deploy a Jetty web server -> Set up instance of Jetty server and configure endpoints.

This creates the Servlet Container

Then add Servlet and endpoints.


Day 4 (2 hours):

The flow of Jetty web server architecture goes like this:

Server --> Servlet Container --> Servlets --> Endpoints

The server is just an HTTP Listener, the servlet container, or the context handler, is what manages what to do 
with the HTTP requests the server recieves. The servlet container does this by managing which servlets handle
each HTTP request depending on URL paths. The endpoints are the implementation details within each Servlet that
handle the specific URL path. All the servlet container knows is the URL pattern e.g /users/* while the Servlet
knows the full path e.g /users/John and the Servlet contains the endpoints to handle that specific URL.

Currently have the Jetty server running with the servlet container, a servlet, and an endpoint configured,
but I am getting 2 errors:
1. Access to fetch at 'http://localhost:8080/user' from origin 'http://localhost:5173' has been blocked by CORS policy: 
   No 'Access-Control-Allow-Origin' header is present on the requested resource.

2. GET http://localhost:8080/user net::ERR_FAILED 405 (Method Not Allowed) 

The first error I understand it as my web browser blocking the response from my backend because my frontend
is running from a different origin (localhost:5173 vs localhost:8080). This blocking is because of Same Origin Policy
that web browsers enforce.

The second error I understand it as my server recieves the HTTP request but rejected the specific method

Solution?

I solved the 2nd error by just adding the doGet method to my servlet lol. I hadn't defined doGet so 
my server didn't know what to do with a GET http method thus ERROR 405. 

While trying to solve the 1st problem, I read into more about CORS and SOP. SOP (Same Origin Policy) is
a security mechanism built into web browsers that prevent a web page's ability to access data from another origin.

Essentially if you go to malware.com, this site could run a script to automatically make an API request
to your-bank.com since the browser automatically includes your session and cookies information, but 
SOP says that since your-bank.com != malware.com, the api request is refused. 

CORS is a server-side permission system that tells browsers which origins are allowed to access the server's resources.


Jakarta is a Java specification, essentially providing interfaces and abstract classes to provides contracts for
enterprise level Java technologies. This iis an example of polymorphism, Jakarta provides the specification
and different frameworks like Tomcat and Jetty implement these specifications. 

Polymorphism - A pillar of OOP - (APIE) - is the ability of one thing to take on many forms.

For instance, a Shape interface can be implemented as a Circle, Rectangle, etc. 

This allows for predictable behaviors, reusable code, and adaptability.

Each circle, rectangle, etc will behave as according to the defined Shape; to get the area of a circle, rectangle, etc
can just call a Shape method, reduces code redundancy, and new shapes can be created with less boilerplate by simply
implementing the Shape interface.

Error 500 means some server side error

Printing a String formatted as a JSON object is a valid json object

Day summary
- Solved cors and server issues

Day 5 (4 hours)

Getting a little confused on how to create an OOP oriented project with Jetty framework and
Jakarta EE specifications.

Should i create new classes that hold Jetty Server objects and deal with all the configurations through
new classes?

Getting stuck on trying to use Jackson to parse Json String to regular string.

Code just doesn't work when I create an ObjectMapper object even though I have all the dependencies needed. 

SO far though, I got the Homepage and the subsequent lobby views "done". 

I can post the username a user enters to the server but I just can't seem to parse the json string.

Somehow fixed the error by mapping to a Player entity.

Day summary:

Front end client can now enter a username and send that username to the server which is parsed with Jackson.
This process also created a Player DTO.

Day 6 (2 hours)

Today I will set up a database connection with the PostgreSQL JDBC driver.

A database driver is a software component that allows applications to interact with a specific DBMS (Database Management System).

TRYING TO GET DATABASE CONNECTION BUT STUPID "java.sql.SQLException: No suitable driver found for jdbc:postgresql://localhost:5432/gameDB" ERROR.

WHY? I have the Maven artifact in my pom.xml. 

Im pretty sure the problem was I was rerunning my Main with old pathfile instead of using VSCode run button... no way right?

Yes, I was using the old Run command genereated from VS Code's run button that used an old snapshot of my .argfile while
the new .argfile is the one that contained the new PostgreSQL JDBC driver dependency. 

Day summary

2 hours just to get a database connection lol. 

Day 7 (2 hours)

I have configured my ServletContainer to use the Jakarta Websocket specification which I think automatically
upgrades a connection to a websocket connection. I think I should make the connection initially just 
http1.1 or 2 or 3 (gotta learn the differences and use cases), and then, I can upgrade those connections
to a websocket connection.

And, I am using the Jakarta EE Servlet APIs and NOT the Jetty server libraries.

scratch that. back to creating the websocket server instance.

Day summary:

dunno didn't do much today. got caught between deciding whether to use jakarta websocket or manually upgrade but
it seems all the underlying networking stuff is already done by abstractions like fetch. 

Did find a way to create json strings easily tho.

Day 8 (~2 hours)

JWT and OAuth2 

JWT is a token format. JWT tokens are JSON encoded data structures containing information about issuer, subject (claims), expiration time etc. 

OAuth2 solves a problem in which user wants to access the data using client software like browser-based web apps, native mobile apps or desktop apps.
OAuth2 is an authorization protocol that MAY USE JWT as a token format, but

Creating my database

Lobby and User

JDBC (java database connectivity)

Lower level, standarized API for connecting to and executing SQL statements to a database

JPA (Java Persistence API)
Higher-level specification for Object-Relational Mapping (ORM). Implemented by frameworks like Hibernate

Persistence simply means to Store Permanently.

A specification defines those you should do in your implementation and it's more suggestive. 

A protocol defines communication rules between two or more different systems. It defines events to drive the communication and actions taken when events received by any side.

Current used Jakarta EE specifications used

Websocket
JDBC
JPA
Servlet

Day 9

A class in the domain model which directly represents a relational database table is called an entity. 

Entities do business logic; but they don’t do orchestration.

1. an entity may compute totals and averages, even caching them if necessary, enforce its invariants, interact with and construct other entities, and so on, and its annotations express how it maps to database tables,

2. but the entity should not call the EntityManager or a Jakarta Data repository, build a criteria query, send a JMS message, start a transaction, publish events to the CDI event bus, maintain a stateful queue of events to be published later, or anything of a similar nature.

The repository is a Java interface that acts as a gateway for accessing persistent data of one or more entity types.

The application must provide the following when using repositories in Jakarta Data:

Entity Classes and Mappings: Developers define a set of entity classes and mappings tailored to a specific data store. These entities represent the data structure and schema, offering a powerful means to interact with the underlying data.

Repository Interfaces: Jakarta Data enables the creation of one or more repository interfaces, following predefined rules that include the guidelines set forth by this specification. These interfaces are the gateways to accessing and manipulating the data, offering a structured and efficient way to perform data operations.

Day 10 ~1.5 hours

Got hibernate to create a new table 

How to use hibernate?

First step is to create a SessionFactory which is pretty much "Hibernate itself." It maintains the runtime metamodel representing persistent entities, their attributes, their associations, and their mappings to relational database tables, along with configuration that affects the runtime behavior of Hibernate, and instances of services that Hibernate needs to perform its duties (SessionFactory javadoc).

Typically, a program has a single SessionFactory instance, and must obtain a new Session instance from the factory each time it services a client request. It is then also responsible for destroying the session at the end of the client request.

A Session extends Java's EntityManager

A Session

Every instance of EntityManager has an associated persistence context. A persistence context is a set of entity instances in which for any given persistent entity identity there is a unique entity instance (Jakarta EE specification docs)

Current issues: Sessionfactory is trying to create a new table when one already exists.

Day 11 1 hour

On each connection, database will create a lobby table with the lobbyid. Though, when I tried having the lobby model hold a set of players, the database didn't work or something. Maybe some issue with the mapping.

What I have learned so far.

I create a Server which holds my servlet container

I configure the servlet container's handlers and add servlets to the container.

Day 12 2 hours

An embedded object is a java object who's persistence is based off the entity it belongs to. A java object as an attribute

I feel like I didn't do much today.

Learned that when I want to map a Java object to another Entity I should use a foreign key (for one to many relationships) as opposed to @ElementCollection.

I think explicitly writing what my next milestone is will be useful, kinda feeling through the dark right now.

My Next Step:

On every client join, create a new lobby and player object and persist into database w/ foreign key mapping.

Day 13 ~1 hour

Didnt really do much. Just reading more about hibernate and how to use the @OneToMany hibernate annotations. Also,
reading Patterns of Enterprise Application Architecture to learn more about design patterns like using a service layer.
Overall, not a super productive day. But, also adding daily journaling for my general daily life. :D

Day 14 ~2 hours

A Singleton is a design pattern that elimnates the need for global variables while allowing for a single instance of a class with global access. However, unlike global variables, a singleton cannot be overwritten.

When using Hibernate for ORM, i need to first map associations between my java classes then map associations to a foreign key column.

Today summary:

Got database to create a lobby w the player on every connection. 

This feature worked once I set the lobby in my player to the lobby i wanted it to join. Not sure how this really works yet
need to read more Hibernate docs and ask AI.

Day 15 ~ 2 hours

Goals:

Get lobby view from database

Didn't get this goal done, but refactored code into layers. Added DAO and Service layers. 

Presentation layer will talk to service layer which will reference DAOs which talk to database

As long as the Jetty server hasn't started, I can add servlets to the handler after I add the handler to the context.

There's a difference between a setter method and a behavior method. Setter is about changing the object's state, behavior method is about describing what the object can do.

A service layer handles business logic and separates presentation from DAOs.

Remember i can use DAOs to get objects from my database

Day 16 ~2 hours

Getting this error jakarta.persistence.EntityExistsException: Detached entity passed to persist: com.backend.model.Lobby
when trying to add player to a lobby. 

This error means im trying to persist a detatched entity, and a detatched entity is an entity with a record in the database but not associated with an active persistence session anymore.

A foreign key is another table’s primary key in table.

Since player has a foreign key to lobby, they're apart of the same domain and should share a service i.e GameService

service layer isnt just for simple queries, its for business logic. 

Business logic are the rules that decide "what is done to data"

DAOs handle all persistence and database actions

Current problem. I have separated my business logic into a service layer and my database querying into a persistence layer, but now, when I'm trying to get a player to join a lobby, im getting the error "Detatched entity passed to persist". 

After some experimenting, this error only occurs when trying to persist a Lobby object. There is no issue with persisting a player object. Even when persisting the lobby object solo... I'm very confused. Is it beacause the Lobby is the one in the ManyToOne relationship?

Hiberate Sessions extend EntityManager and Hibernate SessionFactory extends EntityManagerFactory

Day 17 ~ 2 hours

Currently dont know how to create a lobby based off the lobby id's in my database. How do i know which lobby/player each request comes from??

Session Management is the answer.

Day 18 2 hours

How tf do i do this. Create a playerid and lobbyid on server side but also store web socket id? And do i go through a servlet or just use websockets for players man.

Cant get a connection to my websocket endpoints for some reason. Fixed endpoints

So instead of the clietn setting a post request to my backend, ive created the websocket connection when the client enters a username. 

@NaturalId, designate a non primary key that can be used for lookups

My DAOs // the repository layer is doing the database communication, thus it uses the HibernateUtil singleton which ONLY wraps a SessionFactory static attribute. Makes a lot more sense i since i remove a redundant layer of method calling.

Websocket connection suddenly just stopped working. bruh

Day 19 1 hour

I had bad time management today. 1 hour to debug this WS connection!!! LETS GOOOO

SHITTY

1 hour and didnt fix the problem. No idea why i cant get a connection