Day 1

Goal: 
Create a playable multiplayer web game with pure java in the backend. 
Learn what problems a framework like Spring solves.

The Java API for WebSocket consists of the following packages.

The javax.websocket.server package contains annotations, classes, and interfaces to create and configure server endpoints.

The javax.websocket package contains annotations, classes, interfaces, and exceptions that are common to client and server endpoints.

The process for creating and deploying a WebSocket endpoint follows.

1. Create an endpoint class.

2. Implement the lifecycle methods of the endpoint.

3. Add your business logic to the endpoint.

4. Deploy the endpoint inside a web application.

Java API for Websockets has 2 ways to create an endpoint.

1. Programmatic endpoint (extend Endpoint class and override lifecycle methods)
2. Annotated endpoint (Add annotations to a current class and its methods)

Annotated endpoints are easier to use 

Blocking methods pause the program until execution (sync) and non-blocking
methods allow the program to continue with other tasks (async).

Asynchronous programming is basically executing something without having to wait for it to complete. 

Map<String, Integer> hashMap = new HashMap<>();        // Hash table
Map<String, Integer> treeMap = new TreeMap<>();        // Red-black tree  
Map<String, Integer> concurrentMap = new ConcurrentHashMap<>(); // Thread-safe hash table
The interface on the left just says "I can do Map operations." 
The concrete class on the right says "Here's HOW I actually do those operations."

Unrelated but AWS stuff

EC2 instances are virtual machines that you can provision on AWS
    - unmanaged service; client manages the instances; aws manages the underlying infrastructure


Serverless - cannot access or see underlying infrastructure

AWS Lambda - function as a service; serverless computing

A Lambda is called when a Trigger occurs which could be anything

Lambda instance lasts ~15 minutes

Lambda is good for quick event driven processes

In cloud computing, the term “compute” describes concepts and objects related to software computation. It is a generic term used to reference processing power, memory, networking, storage, and other resources required for the computational success of any program. 

How Lambda works

1. Upload code to Lambda - Lambda Function
2. Configure your code to be triggered by events, like AWS services, mobile apps, or HTTP requests.
3. The Lambda runtime executes your function code using the event data passed to it. 
4. You are charged only for the compute time consumed, down to the millisecond. The price depends on the amount of memory that you allocate to your function.

Containers package code, dependencies, runtime, etc. Everything a program needs to run in a single, portable unit.
    - This creates an isolated and consistent environment.
    - Convenient to scale and deploy anywhere


Day 2

Maven is a build tool that helps with dependency management and build automation.

Maven works by using a pom.xml (Project Object MOdel) as a blueprint for a project. It specifies metdata 
like project name, version, and dependencies, and instructions for building, testing, and packaging.

Maven automatically downloads dependencies that are declared in pom.xml by first checking the
local Maven repository, then remote repositories and stores them in the local repository. 

An anynomous function is an inner class with no name. So it is a class that isnt defined with an (new) class name.
Useful for when you only need an implementation of a function for one thing. 

Each instance of the Endpoint class is associated with one connection.

An embedded server is a server that runs inside a Java application rather than a standalone process.


Day 3 (2 hours):

When you write a WebSocket application using the Jakarta EE jakarta.websocket APIs, your code typically need to depend on just the Jakarta EE WebSocket APIs to compile your application. However, at runtime you need to have an implementation of the Jakarta EE WebSocket APIs in your class-path/module-path.

When writing a WebSocket application with Jakarta EE APIS, your code usually only needs to depend on the 
Jarkarta EE WebSocket APIs. However at runtime, there must be an implementation of 
1. Jarkata EE Websocket APIs 
2. standard Jakarta EE 11 WebSocket APIS

Avaialble w/ Maven artifacts

To correctly configure a WebSocket app based on the standard Jakarta EE 11 Websocket APIs there are 2 steps:
1.  Make sure Jetty sets up an instance of jakarta.websocket.server.ServerContainer
2.  Configure the WebSocket endpoints that implement your application logic

2 ways to deploy web applications:
1. WebAppContext
2. ServletContextHandler

When using ServletContextHandle as in this project, JakartaWebSocketServletContainerInitializer must be initalized
to set up the ServerContainer. 

A servlet is a Java object that is managed by a Servlet container and handles HTTP requests.

A Servlet container is a type of web server that specifically runs Java servlets.

Lambas in Java are expressions that define a single instance of single method classes

The ServerContainer instance is stored as a ServletContext attribute

ServletContext - allows you to define and configure a web application's context, including adding servlets, filters, and listeners, and setting context attributes and init parameters.

Javax was renamed to Jakarta because Oracle gave stewardship of Java EE to the Eclipse foundation.

After a Server/ServerContainer is setup in Jetty, the endpoints must be configured which can be done a few ways.
1. standard jakarta.websocket annotations
2. extend the jakarta.websocket.Endpoint abstract class
3. or implement the jakarta.websocket.server.ServerApplicationConfig interface

Day summary 

Jetty is a Servlet container (a web server that runs Java servlets). A Servlet is a Java object managed
by a Servlet container and handles HTTP requests.

To deploy a Jetty web server -> Set up instance of Jetty server and configure endpoints.

This creates the Servlet Container

Then add Servlet and endpoints.


Day 4 (2 hours):

The flow of Jetty web server architecture goes like this:

Server --> Servlet Container --> Servlets --> Endpoints

The server is just an HTTP Listener, the servlet container, or the context handler, is what manages what to do 
with the HTTP requests the server recieves. The servlet container does this by managing which servlets handle
each HTTP request depending on URL paths. The endpoints are the implementation details within each Servlet that
handle the specific URL path. All the servlet container knows is the URL pattern e.g /users/* while the Servlet
knows the full path e.g /users/John and the Servlet contains the endpoints to handle that specific URL.

Currently have the Jetty server running with the servlet container, a servlet, and an endpoint configured,
but I am getting 2 errors:
1. Access to fetch at 'http://localhost:8080/user' from origin 'http://localhost:5173' has been blocked by CORS policy: 
   No 'Access-Control-Allow-Origin' header is present on the requested resource.

2. GET http://localhost:8080/user net::ERR_FAILED 405 (Method Not Allowed) 

The first error I understand it as my web browser blocking the response from my backend because my frontend
is running from a different origin (localhost:5173 vs localhost:8080). This blocking is because of Same Origin Policy
that web browsers enforce.

The second error I understand it as my server recieves the HTTP request but rejected the specific method

Solution?

I solved the 2nd error by just adding the doGet method to my servlet lol. I hadn't defined doGet so 
my server didn't know what to do with a GET http method thus ERROR 405. 

While trying to solve the 1st problem, I read into more about CORS and SOP. SOP (Same Origin Policy) is
a security mechanism built into web browsers that prevent a web page's ability to access data from another origin.

Essentially if you go to malware.com, this site could run a script to automatically make an API request
to your-bank.com since the browser automatically includes your session and cookies information, but 
SOP says that since your-bank.com != malware.com, the api request is refused. 

CORS is a server-side permission system that tells browsers which origins are allowed to access the server's resources.


Jakarta is a Java specification, essentially providing interfaces and abstract classes to provides contracts for
enterprise level Java technologies. This iis an example of polymorphism, Jakarta provides the specification
and different frameworks like Tomcat and Jetty implement these specifications. 

Polymorphism - A pillar of OOP - (APIE) - is the ability of one thing to take on many forms.

For instance, a Shape interface can be implemented as a Circle, Rectangle, etc. 

This allows for predictable behaviors, reusable code, and adaptability.

Each circle, rectangle, etc will behave as according to the defined Shape; to get the area of a circle, rectangle, etc
can just call a Shape method, reduces code redundancy, and new shapes can be created with less boilerplate by simply
implementing the Shape interface.

Error 500 means some server side error

Printing a String formatted as a JSON object is a valid json object

Day summary
- Solved cors and server issues

Day 5 (4 hours)

Getting a little confused on how to create an OOP oriented project with Jetty framework and
Jakarta EE specifications.

Should i create new classes that hold Jetty Server objects and deal with all the configurations through
new classes?

Getting stuck on trying to use Jackson to parse Json String to regular string.

Code just doesn't work when I create an ObjectMapper object even though I have all the dependencies needed. 

SO far though, I got the Homepage and the subsequent lobby views "done". 

I can post the username a user enters to the server but I just can't seem to parse the json string.

Somehow fixed the error by mapping to a Player entity.

Day summary:

Front end client can now enter a username and send that username to the server which is parsed with Jackson.
This process also created a Player DTO.

Day 6 (2 hours)

Today I will set up a database connection with the PostgreSQL JDBC driver.

A database driver is a software component that allows applications to interact with a specific DBMS (Database Management System).

TRYING TO GET DATABASE CONNECTION BUT STUPID "java.sql.SQLException: No suitable driver found for jdbc:postgresql://localhost:5432/gameDB" ERROR.

WHY? I have the Maven artifact in my pom.xml. 

Im pretty sure the problem was I was rerunning my Main with old pathfile instead of using VSCode run button... no way right?

Yes, I was using the old Run command genereated from VS Code's run button that used an old snapshot of my .argfile while
the new .argfile is the one that contained the new PostgreSQL JDBC driver dependency. 

Day summary

2 hours just to get a database connection lol. 

Day 7 (2 hours)

I have configured my ServletContainer to use the Jakarta Websocket specification which I think automatically
upgrades a connection to a websocket connection. I think I should make the connection initially just 
http1.1 or 2 or 3 (gotta learn the differences and use cases), and then, I can upgrade those connections
to a websocket connection.

And, I am using the Jakarta EE Servlet APIs and NOT the Jetty server libraries.

scratch that. back to creating the websocket server instance.

Day summary:

dunno didn't do much today. got caught between deciding whether to use jakarta websocket or manually upgrade but
it seems all the underlying networking stuff is already done by abstractions like fetch. 

Did find a way to create json strings easily tho.

Day 8 (~2 hours)

JWT and OAuth2 

JWT is a token format. JWT tokens are JSON encoded data structures containing information about issuer, subject (claims), expiration time etc. 

OAuth2 solves a problem in which user wants to access the data using client software like browser-based web apps, native mobile apps or desktop apps.
OAuth2 is an authorization protocol that MAY USE JWT as a token format, but

Creating my database

Lobby and User

JDBC (java database connectivity)

Lower level, standarized API for connecting to and executing SQL statements to a database

JPA (Java Persistence API)
Higher-level specification for Object-Relational Mapping (ORM). Implemented by frameworks like Hibernate

Persistence simply means to Store Permanently.

A specification defines those you should do in your implementation and it's more suggestive. 

A protocol defines communication rules between two or more different systems. It defines events to drive the communication and actions taken when events received by any side.

Current used Jakarta EE specifications used

Websocket
JDBC
JPA
Servlet